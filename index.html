<!DOCTYPE html><html lang="fr"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Mon Livre PDF – Flipbook</title>

<style>
 body{margin:0;background:#111;color:#fff;font-family:sans-serif;overflow:hidden}
 h1{margin:10px 0;text-align:center;font-size:clamp(22px,6vw,36px)}
 .bar{display:flex;justify-content:center;gap:8px;flex-wrap:wrap}
 button{padding:8px 16px;border:0;background:#444;color:#fff;border-radius:5px;font-size:15px;cursor:pointer}
 button:disabled{opacity:.4;cursor:not-allowed}
 #status{align-self:center;white-space:nowrap}
 #container{display:flex;justify-content:center;align-items:center;height:calc(100vh - 96px)}
 #flipbook{display:none;background:#222}
 canvas{background:#fff}
 :fullscreen #flipbook{width:100vw!important;height:100vh!important}
</style>

<!-- dépendances -->
<script src="libs/jquery.min.js"></script>
<script src="libs/turn.min.js"></script>
<script src="libs/pdf.min.js"></script>
<script>
  /* chemin du worker */
  pdfjsLib.GlobalWorkerOptions.workerSrc = 'libs/pdf.worker.min.js';
</script>
</head><body>

<h1>Mon Livre PDF</h1>
<div class="bar">
  <button id="prev" disabled>&laquo; Précédent</button>
  <button id="next" disabled>Suivant &raquo;</button>
  <button id="fs">Plein écran ⤢</button>
  <span id="status">Chargement…</span>
</div>

<div id="container"><div id="flipbook"></div></div>

<script>
const PDF_URL = 'pdf/livre.pdf';
const flip    = $('#flipbook');
const stat    = $('#status');
const prevBtn = $('#prev');
const nextBtn = $('#next');
const fsBtn   = $('#fs');

let pdfDoc,total,zoom=1;

const doubleMode=()=>innerWidth>=768||matchMedia('(orientation:landscape)').matches;

function scale(vp){
  const head=document.querySelector('.bar').offsetHeight+40;
  const w=innerWidth-32,h=innerHeight-head,p=doubleMode()?2:1;
  return (p===1?w/vp.width:Math.min((w/p)/vp.width,h/vp.height))*zoom;
}

async function canvasFromPage(i){
  const page=await pdfDoc.getPage(i);
  const vp1=page.getViewport({scale:1}), sc=scale(vp1), vp=page.getViewport({scale:sc});
  const c=document.createElement('canvas'); c.width=vp.width; c.height=vp.height;
  await page.render({canvasContext:c.getContext('2d'),viewport:vp}).promise;
  return c;
}

async function build(){
  try{flip.turn('destroy').empty();}catch{}
  stat.text('Chargement…');
  if(!pdfDoc){pdfDoc=await pdfjsLib.getDocument(PDF_URL).promise; total=pdfDoc.numPages;}

  for(let i=1;i<=total;i++) $('<div>').append(await canvasFromPage(i)).appendTo(flip);

  const first=flip.find('canvas')[0];
  flip.turn({display:doubleMode()?'double':'single',width:first.width*(doubleMode()?2:1),height:first.height,autoCenter:true,gradients:true,duration:600}).show();
  stat.text(`${total} pages`);
  prevBtn.prop('disabled',false); nextBtn.prop('disabled',false);
}

prevBtn.on('click',()=>flip.turn('previous'));
nextBtn.on('click',()=>flip.turn('next'));

flip.on('touchstart',e=>flip.data('x0',e.touches[0].clientX));
flip.on('touchend',e=>{
  const x0=flip.data('x0'); if(x0==null)return;
  const dx=x0-e.changedTouches[0].clientX;
  if(dx>50)flip.turn('next'); if(dx<-50)flip.turn('previous'); flip.removeData('x0');
});

flip.on('dblclick',()=>{zoom=zoom===1?1.4:1; build();});

fsBtn.on('click',()=>{
  const el=document.documentElement;
  (!document.fullscreenElement?el.requestFullscreen:document.exitFullscreen).call(el);
});
addEventListener('resize',build);

build().catch(e=>{stat.text('Erreur : '+e.message);console.error(e);});
</script>
</body></html>
